import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';
import { saveToDB, loadFromDB, clearDB } from '../services/db';
import { onForegroundMessage, requestNotificationPermission, showNativeNotification } from '../services/firebaseService';
import { GoogleGenAI, FunctionDeclaration, Type } from "@google/genai";

// Types
export interface AIProfile {
  id: string;
  name: string;
  personality: string;
  backstory: string;
  appearance: string;
  referenceImage: string | null; // Base64
  voiceURI: string | null;
  voicePitch: number;
  voiceSpeed: number;
  autoReadMessages: boolean;
  voiceGender: 'male' | 'female' | 'none';
  responseStyle: string;
  proactiveMessageFrequency: 'very_frequently' | 'frequently' | 'occasionally' | 'rarely' | 'off';
  responseLength: number; // Measured in number of paragraphs
  responseDetail: 'Concise' | 'Standard' | 'Detailed' | 'Verbose';
  responseTone: 'Neutral' | 'Serious' | 'Humorous' | 'Professional' | 'Flirty' | 'Empathetic' | 'Sarcastic';
  customParagraphCount: number | null;
  customWordCount: number | null;
  model?: string;
  temperature?: number;
  topK?: number;
  topP?: number;
  timeAwareness: boolean;
  ambientMode: boolean;
  ambientFrequency: 'very_frequently' | 'frequently' | 'occasionally' | 'rarely' | 'off';
  aiCanGenerateImages: boolean;
}

const generateImageFunction: FunctionDeclaration = {
  name: "generateImage",
  description: "Generates an image based on a detailed text prompt. The image will be displayed to the user in the chat and saved to their gallery.",
  parameters: {
    type: Type.OBJECT,
    properties: {
      prompt: {
        type: Type.STRING,
        description: "A detailed, descriptive prompt for the image to be generated. Be specific about style, subject, and any desired elements.",
      },
    },
    required: ["prompt"],
  },
};

export interface UserProfile {
  name: string;
  info: string;
  preferences: string;
  appearance: string;
  referenceImage: string | null; // Base64 encoded image for AI to 'see'
}

export interface ChatMessage {
  id: string;
  role: 'user' | 'model';
  content: string;
  timestamp: number;
  attachments?: { type: 'image' | 'text' | 'pdf'; content: string; name: string }[];
  groundingUrls?: { title: string; url: string }[];
}

export interface GalleryItem {
  id: string;
  type: 'uploaded' | 'generated';
  url: string; // Base64 or Blob URL
  prompt?: string;
  timestamp: number;
}

export interface JournalEntry {
  id: string;
  date: string;
  content: string;
  isAutoGenerated: boolean;
}

export interface Memory {
  id: string;
  content: string;
  strength: number; // 1-10
  timestamp: number;
  lastAccessed: number; // Timestamp of last access
  isImportant: boolean; // Flag to prioritize memory
}

export interface Toast {
  id: string;
  title: string;
  message: string;
  type: 'info' | 'success' | 'warning' | 'error';
  timestamp: number;
}

interface AppState {
  aiProfile: AIProfile;
  savedPersonas: AIProfile[];
  userProfile: UserProfile;
  chatHistory: ChatMessage[];
  gallery: GalleryItem[];
  journal: JournalEntry[];
  knowledgeBase: { name: string; content: string }[]; // Simple text files
  memories: Memory[];
  toasts: Toast[];
  apiKey: string | null;
  autoSaveChat: boolean;
  autoSaveChatInterval: number; // in seconds
  autoJsonBackup: boolean;
  autoJsonBackupInterval: number; // in minutes
  autoDriveBackup: boolean;
  isGoogleDriveConnected: boolean;
  proactiveMessageFrequency: 'very_frequently' | 'frequently' | 'occasionally' | 'rarely' | 'off';
  notificationsEnabled: boolean;
  fcmToken: string | null;
  showTimestamps: boolean;
  ambientMode: boolean;
  ambientFrequency: 'very_frequently' | 'frequently' | 'occasionally' | 'rarely' | 'off';
  aiCanGenerateImages: boolean;
}

interface AppContextType extends AppState {
  setAIProfile: (profile: AIProfile) => void;
  savePersona: (profile: AIProfile) => void;
  deletePersona: (id: string) => void;
  loadPersona: (id: string) => void;
  setUserProfile: (profile: UserProfile) => void;
  setUserReferenceImage: (image: string | null) => void;
  setFcmToken: (token: string | null) => void;
  addChatMessage: (message: ChatMessage) => void;
  updateChatMessage: (id: string, newContent: string) => void;
  deleteChatMessage: (id: string) => void;
  setChatHistory: (history: ChatMessage[]) => void;
  addToGallery: (item: GalleryItem) => void;
  deleteImageFromGallery: (id: string) => void;
  addJournalEntry: (entry: JournalEntry) => void;
  updateJournalEntry: (id: string, updates: Partial<JournalEntry>) => void;
  deleteJournalEntry: (id: string) => void;
  addToKnowledgeBase: (file: { name: string; content: string }) => void;
  addMemory: (memory: Memory) => void;
  updateMemory: (id: string, updates: Partial<Memory>) => void;
  deleteMemory: (id: string) => void;
  addToast: (toast: Omit<Toast, 'id' | 'timestamp'>) => void;
  removeToast: (id: string) => void;
  resetApp: () => Promise<void>;
  exportData: () => Promise<string>;
  importData: (json: string) => void;
  clearHistory: () => void;
  setApiKey: (key: string | null) => void;
  showTutorial: boolean;
  setShowTutorial: (show: boolean) => void;
  setAutoSaveChat: (enabled: boolean) => void;
  setAutoSaveChatInterval: (interval: number) => void;
  setAutoJsonBackup: (enabled: boolean) => void;
  setAutoJsonBackupInterval: (interval: number) => void;
  setAutoDriveBackup: (enabled: boolean) => void;
  setIsGoogleDriveConnected: (connected: boolean) => void;
  setNotificationsEnabled: (enabled: boolean) => void;
  setShowTimestamps: (show: boolean) => void;
  setProactiveMessageFrequency: (frequency: 'very_frequently' | 'frequently' | 'occasionally' | 'rarely' | 'off') => void;
  setAmbientMode: (enabled: boolean) => void;
  setAmbientFrequency: (frequency: 'very_frequently' | 'frequently' | 'occasionally' | 'rarely' | 'off') => void;
  setAiCanGenerateImages: (enabled: boolean) => void;
}

const AppContext = createContext<AppContextType | undefined>(undefined);

export const AppProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  // Initial States
  const [showTutorial, setShowTutorial] = useState(false);
  const [aiProfile, setAIProfileState] = useState<AIProfile>({
    id: 'default',
    name: 'Indigo',
    personality: 'Helpful, creative, and observant.',
    backstory: 'I am an AI companion created to assist and inspire.',
    appearance: 'A digital entity with a calming indigo aura.',
    referenceImage: null,
    voiceURI: null,
    voicePitch: 1.0,
    voiceSpeed: 1.0,
    autoReadMessages: false,
    voiceGender: 'none',
    responseStyle: 'Detailed',
    responseLength: 2,
    proactiveMessageFrequency: 'off',
    model: 'gemini-3.1-pro-preview',
    temperature: 0.7,
    topK: 40,
    topP: 0.95,
    timeAwareness: true,
    ambientMode: false,
    ambientFrequency: 'off',
    aiCanGenerateImages: false,
  });

  const [savedPersonas, setSavedPersonas] = useState<AIProfile[]>([]);

  const [userProfile, setUserProfileState] = useState<UserProfile>({
    name: 'User',
    info: '',
    preferences: '',
    appearance: '',
    referenceImage: null,
  });

  const [chatHistory, setChatHistory] = useState<ChatMessage[]>([]);
  const [gallery, setGallery] = useState<GalleryItem[]>([]);
  const [journal, setJournal] = useState<JournalEntry[]>([]);
  const [knowledgeBase, setKnowledgeBase] = useState<{ name: string; content: string }[]>([]);
  const [memories, setMemories] = useState<Memory[]>([]);
  const [toasts, setToasts] = useState<Toast[]>([]);
  const [apiKey, setApiKeyState] = useState<string | null>(null);
  const [autoSaveChat, setAutoSaveChatState] = useState(true);
  const [autoSaveChatInterval, setAutoSaveChatInterval] = useState(30); // Default 30 seconds
  const [autoJsonBackup, setAutoJsonBackupState] = useState(false);
  const [autoJsonBackupInterval, setAutoJsonBackupInterval] = useState(5); // Default 5 minutes
  const [autoDriveBackup, setAutoDriveBackupState] = useState(false);
  const [isGoogleDriveConnected, setIsGoogleDriveConnected] = useState(false);
  const [notificationsEnabled, setNotificationsEnabledState] = useState(
    typeof Notification !== 'undefined' && Notification.permission === 'granted'
  );
  const [fcmToken, setFcmTokenState] = useState<string | null>(null);
  const [showTimestamps, setShowTimestampsState] = useState(true);
  const [lastInteractionTime, setLastInteractionTime] = useState(Date.now());
  const [isLoaded, setIsLoaded] = useState(false);
  const MAX_MEMORIES = 20; // Define maximum number of memories

  const initialAIProfileState: AIProfile = {
    id: 'default',
    name: 'Indigo',
    personality: 'Helpful, creative, and observant.',
    backstory: 'I am an AI companion created to assist and inspire.',
    appearance: 'A digital entity with a calming indigo aura.',
    referenceImage: null,
    voiceURI: null,
    voicePitch: 1.0,
    voiceSpeed: 1.0,
    autoReadMessages: false,
    voiceGender: 'none',
    responseStyle: 'Standard',
    responseLength: 2,
    responseDetail: 'Standard',
    responseTone: 'Neutral',
    customParagraphCount: null,
    customWordCount: null,
    proactiveMessageFrequency: 'off',
    model: 'gemini-3.1-pro-preview',
    temperature: 0.7,
    topK: 40,
    topP: 0.95,
    timeAwareness: true,
    ambientMode: false,
    ambientFrequency: 'off',
    aiCanGenerateImages: false,
  };

  const initialUserProfileState: UserProfile = {
    name: 'User',
    info: '',
    preferences: '',
    appearance: '',
  };

  // Function to prune or consolidate memories
  const pruneMemories = (currentMemories: Memory[]): Memory[] => {
    if (currentMemories.length <= MAX_MEMORIES) {
      return currentMemories;
    }

    // Separate important memories
    const importantMemories = currentMemories.filter(m => m.isImportant);
    let nonImportantMemories = currentMemories.filter(m => !m.isImportant);

    // If important memories alone exceed limit, prune them too (e.g., oldest important first)
    if (importantMemories.length > MAX_MEMORIES) {
      return importantMemories.sort((a, b) => a.timestamp - b.timestamp).slice(0, MAX_MEMORIES);
    }

    // Sort non-important memories: by strength (ascending), then by lastAccessed (ascending - oldest first)
    nonImportantMemories.sort((a, b) => {
      if (a.strength !== b.strength) {
        return a.strength - b.strength;
      }
      return a.lastAccessed - b.lastAccessed; // Prioritize older/less accessed for pruning
    });

    // Determine how many non-important memories to keep
    const numToKeep = MAX_MEMORIES - importantMemories.length;
    let keptNonImportantMemories = nonImportantMemories.slice(0, numToKeep);

    // Combine and return
    return [...importantMemories, ...keptNonImportantMemories];
  };

  // Load from IndexedDB on mount
  useEffect(() => {
    const loadData = async () => {
        try {
            const savedData = await loadFromDB('indigo_app_data');
            if (savedData) {
                // Ensure ID exists for legacy data
                const loadedProfile = savedData.aiProfile || initialAIProfileState;
                if (!loadedProfile.id) loadedProfile.id = 'default';
                
                setAIProfileState(prev => ({
            ...initialAIProfileState, // Provide defaults for new fields
            ...loadedProfile,
            ambientMode: loadedProfile.ambientMode ?? false,
            ambientFrequency: loadedProfile.ambientFrequency || 'off',
            aiCanGenerateImages: loadedProfile.aiCanGenerateImages ?? false,
          }));
                setSavedPersonas(savedData.savedPersonas || [loadedProfile]);
                setUserProfileState(savedData.userProfile || initialUserProfileState);
                setChatHistory(Array.isArray(savedData.chatHistory) ? savedData.chatHistory : []);
                setGallery(Array.isArray(savedData.gallery) ? savedData.gallery : []);
                setJournal(Array.isArray(savedData.journal) ? savedData.journal : []);
                setKnowledgeBase(Array.isArray(savedData.knowledgeBase) ? savedData.knowledgeBase : []);
                setMemories(Array.isArray(savedData.memories) ? savedData.memories : []);
                setApiKeyState(savedData.apiKey || null);
                setFcmTokenState(savedData.fcmToken || null);
                setAutoSaveChatState(savedData.autoSaveChat !== undefined ? savedData.autoSaveChat : true);
                setAutoSaveChatInterval(savedData.autoSaveChatInterval !== undefined ? savedData.autoSaveChatInterval : 30);
                setAutoJsonBackupState(savedData.autoJsonBackup !== undefined ? savedData.autoJsonBackup : false);
                setAutoJsonBackupInterval(savedData.autoJsonBackupInterval !== undefined ? savedData.autoJsonBackupInterval : 5);
                setNotificationsEnabledState(savedData.notificationsEnabled !== undefined ? savedData.notificationsEnabled : (typeof Notification !== 'undefined' && Notification.permission === 'granted'));
            } else {
                // Initialize saved personas with default if empty
                setSavedPersonas([initialAIProfileState]);
            }
        } catch (e) {
            console.error("Failed to load saved data from DB during app initialization:", e);
            // Optionally, clear local storage or IndexedDB here if data corruption is suspected
            // For now, just log and proceed with default states
        } finally {
            setIsLoaded(true);
        }
    };
    loadData();
  }, []);

  // Check Google Drive status on mount
  useEffect(() => {
    const checkDriveStatus = async () => {
      try {
        const res = await fetch('/api/auth/google/status');
        if (res.ok) {
          const data = await res.json();
          setIsGoogleDriveConnected(data.isAuthenticated);
        }
      } catch (e) {
        console.error("Failed to check Google Drive status", e);
      }
    };
    checkDriveStatus();
  }, []);

  const saveData = useCallback(async () => {
    if (!isLoaded) return; // Don't save before initial load is complete

    try {
      const data: AppState = {
          aiProfile,
          savedPersonas,
          userProfile,
          chatHistory,
          gallery,
          journal,
          knowledgeBase,
          memories,
          toasts: [],
          apiKey,
          autoSaveChat,
          autoSaveChatInterval,
          autoJsonBackup,
          autoJsonBackupInterval,
          autoDriveBackup,
          isGoogleDriveConnected,
          proactiveMessageFrequency: aiProfile.proactiveMessageFrequency,
          notificationsEnabled,
          fcmToken,
          showTimestamps,
          ambientMode: aiProfile.ambientMode,
          ambientFrequency: aiProfile.ambientFrequency,
          aiCanGenerateImages: aiProfile.aiCanGenerateImages,
      };
      await saveToDB('indigo_app_data', data);
    } catch (e) {
      console.error("Failed to save data to DB", e);
    }

    // Debounce save to avoid excessive writes
  }, [aiProfile, savedPersonas, userProfile, chatHistory, gallery, journal, knowledgeBase, memories, apiKey, fcmToken, autoSaveChat, autoJsonBackup, autoDriveBackup, isLoaded, isGoogleDriveConnected, lastInteractionTime]);

  // Debounce save to avoid excessive writes
  useEffect(() => {
    if (!isLoaded) return;
    const timeoutId = setTimeout(saveData, 1000);
    return () => clearTimeout(timeoutId);
  }, [aiProfile, savedPersonas, userProfile, chatHistory, gallery, journal, knowledgeBase, memories, apiKey, fcmToken, autoSaveChat, autoJsonBackup, autoDriveBackup, isLoaded, isGoogleDriveConnected, lastInteractionTime]);

  // Initialize Firebase and handle foreground messages
  useEffect(() => {
    if (!isLoaded) return;

    const setupNotifications = async () => {
      const result = await requestNotificationPermission();
      if (result.success && result.token) {
        setFcmTokenState(result.token);
        addToast({ title: "Push Notifications", message: result.message, type: "success" });
      } else {
        addToast({ title: "Push Notifications", message: result.message, type: "error" });
      }
    };
    setupNotifications();

    const unsubscribe = onForegroundMessage((payload) => {
      const title = payload.notification?.title || aiProfile.name;
      const body = payload.notification?.body || "New message received";

      addToast({
        title,
        message: body,
        type: 'info'
      });
      
      // Show native notification even in foreground if permitted
      if (notificationsEnabled) {
        showNativeNotification(title, {
          body,
          icon: '/indigo-icon.png'
        });
      }
      
      // Optionally add to chat history if it's a chat message
      if (payload.data?.type === 'chat') {
        const imageBase64 = payload.data?.image;
        if (imageBase64) {
          const imageUrl = `data:image/png;base64,${imageBase64}`;
          addToGallery({
            id: `generated-${Date.now()}`,
            type: 'generated',
            url: imageUrl,
            prompt: body, // Use notification body as prompt for context
            timestamp: Date.now(),
          });
          addChatMessage({
            id: `fcm-${Date.now()}`,
            role: 'model',
            content: body,
            timestamp: Date.now(),
            attachments: [{ type: 'image', content: imageUrl, name: 'Generated Image' }]
          });
        } else {
          addChatMessage({
            id: `fcm-${Date.now()}`,
            role: 'model',
            content: body,
            timestamp: Date.now(),
          });
        }
      }
    });

    return () => {
      if (unsubscribe) unsubscribe();
    };
  }, [isLoaded, aiProfile.name]);

  // Auto-Save Chat History Interval (30s)
  useEffect(() => {
    if (!isLoaded || !autoSaveChat || autoSaveChatInterval <= 0) return;

    const intervalId = setInterval(async () => {
        try {
            // We save the entire state to ensure consistency, but specifically for chat history persistence
            const data: AppState = {
                aiProfile,
                savedPersonas,
                userProfile,
                chatHistory,
                gallery,
                journal,
                knowledgeBase,
                memories,
                toasts: [],
                apiKey,
                autoSaveChat,
                autoSaveChatInterval,
                autoJsonBackup,
                autoJsonBackupInterval,
                autoDriveBackup,
                isGoogleDriveConnected,
                proactiveMessageFrequency: aiProfile.proactiveMessageFrequency,
                notificationsEnabled,
                fcmToken,
                showTimestamps,
                ambientMode: aiProfile.ambientMode,
                ambientFrequency: aiProfile.ambientFrequency,
                aiCanGenerateImages: aiProfile.aiCanGenerateImages,
            };
            await saveToDB('indigo_app_data', data);
            console.log(`Auto-saved chat history (${autoSaveChatInterval}s interval)`);
        } catch (e) {
            console.error("Failed to auto-save chat history", e);
        }
    }, autoSaveChatInterval * 1000);

    return () => clearInterval(intervalId);
  }, [isLoaded, autoSaveChat, autoSaveChatInterval, aiProfile, savedPersonas, userProfile, chatHistory, gallery, journal, knowledgeBase, memories, apiKey, fcmToken, autoJsonBackup, autoJsonBackupInterval]);

  // Auto JSON Backup Interval (e.g., every 5 minutes if enabled)
  useEffect(() => {
    if (!isLoaded || !autoJsonBackup || autoJsonBackupInterval <= 0) return;

    const intervalId = setInterval(async () => {
        try {
            const data = JSON.stringify({
                aiProfile,
                savedPersonas,
                userProfile,
                chatHistory,
                gallery,
                journal,
                knowledgeBase,
                memories,
                apiKey,
                autoSaveChat,
                autoSaveChatInterval,
                autoJsonBackup,
                autoJsonBackupInterval,
                autoDriveBackup,
                isGoogleDriveConnected,
                proactiveMessageFrequency: aiProfile.proactiveMessageFrequency,
                notificationsEnabled,
                aiCanGenerateImages: aiProfile.aiCanGenerateImages,
            }, null, 2);
            
            const now = new Date();
            const filename = `indigoAI_backup_${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}_${now.getMinutes().toString().padStart(2, '0')}_${now.getSeconds().toString().padStart(2, '0')}.json`;
            
            // Simulate saving to a file. In a real app, this would trigger a file download or server-side save.
            console.log(`Simulating auto-backup: Would save as file '${filename}' with content:`, data);
            
            // For demonstration, we'll still store the latest backup in localStorage for easy inspection
            localStorage.setItem('indigo_auto_backup_json', data);
            console.log(`Auto-backed up JSON to localStorage (filename: ${filename})`);
        } catch (e) {
            console.error("Failed to auto-backup JSON", e);
        }
    }, autoJsonBackupInterval * 60 * 1000); // Convert minutes to milliseconds

    return () => clearInterval(intervalId);
  }, [isLoaded, autoJsonBackup, autoJsonBackupInterval, aiProfile, savedPersonas, userProfile, chatHistory, gallery, journal, knowledgeBase, memories, apiKey, autoSaveChat, autoSaveChatInterval]);

  // Auto Google Drive Backup Interval
  useEffect(() => {
    if (!isLoaded || !autoDriveBackup || autoJsonBackupInterval <= 0 || !isGoogleDriveConnected) return;

    const intervalId = setInterval(async () => {
      try {
        const data = JSON.stringify({
          aiProfile,
          savedPersonas,
          userProfile,
          chatHistory,
          gallery,
          journal,
          knowledgeBase,
          memories,
          apiKey,
          autoSaveChat,
          autoSaveChatInterval,
          autoJsonBackup,
          autoJsonBackupInterval,
          autoDriveBackup,
          isGoogleDriveConnected,
          proactiveMessageFrequency: aiProfile.proactiveMessageFrequency,
          notificationsEnabled,
        }, null, 2);

        const now = new Date();
        const filename = `indigoAI_drive_backup_${now.getFullYear()}-${(now.getMonth() + 1).toString().padStart(2, '0')}-${now.getDate().toString().padStart(2, '0')}_${now.getHours().toString().padStart(2, '0')}_${now.getMinutes().toString().padStart(2, '0')}_${now.getSeconds().toString().padStart(2, '0')}.json`;

        const res = await fetch('/api/drive/upload', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ filename, content: data }),
        });

        if (res.ok) {
          console.log(`Auto-backed up to Google Drive (filename: ${filename})`);
        } else {
          console.error("Failed to auto-backup to Google Drive", await res.json());
        }
      } catch (e) {
        console.error("Failed to auto-backup to Google Drive", e);
      }
    }, autoJsonBackupInterval * 60 * 1000); // Use autoJsonBackupInterval for Drive backup frequency

    return () => clearInterval(intervalId);
  }, [isLoaded, autoDriveBackup, autoJsonBackupInterval, isGoogleDriveConnected, aiProfile, savedPersonas, userProfile, chatHistory, gallery, journal, knowledgeBase, memories, apiKey, autoSaveChat, autoSaveChatInterval, autoJsonBackup]);

  // Proactive Message Trigger
  useEffect(() => {
    if (!isLoaded || aiProfile.proactiveMessageFrequency === 'off') return;

    const getInterval = (frequency: typeof aiProfile.proactiveMessageFrequency) => {
      switch (frequency) {
        case 'very_frequently': return 5 * 60 * 1000; // 5 minutes
        case 'frequently': return 15 * 60 * 1000; // 15 minutes
        case 'occasionally': return 30 * 60 * 1000; // 30 minutes
        case 'rarely': return 60 * 60 * 1000; // 60 minutes
        default: return Infinity;
      }
    };

    const interval = getInterval(aiProfile.proactiveMessageFrequency);
    if (interval === Infinity) return;

    const checkProactiveMessage = async () => {
      const now = Date.now();
      const timeSinceLastInteraction = now - lastInteractionTime;

      if (timeSinceLastInteraction >= interval) {
        const hasNotificationSupport = typeof Notification !== 'undefined';
        
        if (hasNotificationSupport && Notification.permission === 'default') {
          try {
            await Notification.requestPermission();
          } catch (e) {
            console.error("Error requesting notification permission in background:", e);
          }
        }

        try {
          const res = await fetch('/api/proactive-message', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              chatHistory: chatHistory.slice(-5),
              aiProfile,
              userProfile,
              apiKey: apiKey || undefined,
              fcmToken: fcmToken || undefined,
            }),
          });

          if (res.ok) {
            const { message, generatedImage } = await res.json();
            
            if (generatedImage) {
              const imageUrl = `data:image/png;base64,${generatedImage}`;
              addToGallery({
                id: `generated-${Date.now()}`,
                type: 'generated',
                url: imageUrl,
                prompt: message || "AI generated image",
                timestamp: Date.now(),
              });
              addChatMessage({
                id: `proactive-${Date.now()}`,
                role: 'model',
                content: message || "Here's an image I thought you'd like!",
                timestamp: Date.now(),
                attachments: [{ type: 'image', content: imageUrl, name: 'Generated Image' }]
              });
            } else if (message) {
              // If no image, but there's a message, add it to chat
              addChatMessage({
                id: `proactive-${Date.now()}`,
                role: 'model',
                content: message,
                timestamp: Date.now(),
              });
            }
            
            setLastInteractionTime(Date.now());
          } else {
            console.error("Failed to generate proactive message:", await res.json());
          }
        } catch (e) {
          console.error("Error sending proactive message:", e);
        }
      }
    };

    const intervalId = setInterval(checkProactiveMessage, interval);
    return () => clearInterval(intervalId);

  }, [isLoaded, aiProfile.proactiveMessageFrequency, lastInteractionTime, aiProfile, userProfile, chatHistory]);

  const setAutoSaveChat = (enabled: boolean) => setAutoSaveChatState(enabled);
  const setAutoJsonBackup = (enabled: boolean) => setAutoJsonBackupState(enabled);
  const setAutoDriveBackup = (enabled: boolean) => setAutoDriveBackupState(enabled);

  const setProactiveMessageFrequency = (frequency: 'very_frequently' | 'frequently' | 'occasionally' | 'rarely' | 'off') => {
    setAIProfileState(prev => ({ ...prev, proactiveMessageFrequency: frequency }));
  };

  const setNotificationsEnabled = (enabled: boolean) => setNotificationsEnabledState(enabled);

  const setAIProfile = (profile: AIProfile) => setAIProfileState(profile);
  
  const savePersona = (profile: AIProfile) => {
    setSavedPersonas(prev => {
        const existingIndex = prev.findIndex(p => p.id === profile.id);
        if (existingIndex >= 0) {
            const newPersonas = [...prev];
            newPersonas[existingIndex] = profile;
            return newPersonas;
        } else {
            return [...prev, profile];
        }
    });
    // Also update current if it matches
    if (aiProfile.id === profile.id) {
        setAIProfileState(profile);
    }
  };

  const deletePersona = (id: string) => {
    setSavedPersonas(prev => prev.filter(p => p.id !== id));
    // If deleting current, switch to another or default
    if (aiProfile.id === id) {
        const remaining = savedPersonas.filter(p => p.id !== id);
        if (remaining.length > 0) {
            setAIProfileState(remaining[0]);
        } else {
            // Reset to default if no personas left
            setAIProfileState(initialAIProfileState);
        }
    }
  };

  const loadPersona = (id: string) => {
    const persona = savedPersonas.find(p => p.id === id);
    if (persona) {
        setAIProfileState(persona);
    }
  };

  const setUserProfile = (profile: UserProfile) => setUserProfileState(profile);

  const setUserReferenceImage = (image: string | null) => {
    setUserProfileState(prev => ({ ...prev, referenceImage: image }));
    saveData();
  };
  
  const addChatMessage = (message: ChatMessage) => {
    setChatHistory(prev => [...prev, message]);
  };

  const updateChatMessage = (id: string, newContent: string) => {
    setChatHistory(prev => prev.map(msg => msg.id === id ? { ...msg, content: newContent } : msg));
  };

  const deleteChatMessage = (id: string) => {
    setChatHistory(prev => prev.filter(msg => msg.id !== id));
  };

  const addToGallery = (item: GalleryItem) => {
    setGallery(prev => [item, ...prev]);
  };

  const deleteImageFromGallery = (id: string) => {
    setGallery(prev => prev.filter(item => item.id !== id));
  };

  const addJournalEntry = (entry: JournalEntry) => {
    setJournal(prev => [entry, ...prev]);
  };

  const updateJournalEntry = (id: string, updates: Partial<JournalEntry>) => {
    setJournal(prev => prev.map(entry => entry.id === id ? { ...entry, ...updates } : entry));
  };

  const deleteJournalEntry = (id: string) => {
    setJournal(prev => prev.filter(entry => entry.id !== id));
  };

  const addToKnowledgeBase = (file: { name: string; content: string }) => {
    setKnowledgeBase(prev => [...prev, file]);
  };

  const addMemory = (memory: Memory) => {
    setMemories(prev => pruneMemories([...prev, { ...memory, lastAccessed: Date.now(), isImportant: memory.isImportant || false }]));
  };

  const updateMemory = (id: string, updates: Partial<Memory>) => {
    setMemories(prev => prev.map(m => m.id === id ? { ...m, ...updates, lastAccessed: Date.now() } : m));
  };

  const deleteMemory = (id: string) => {
    setMemories(prev => prev.filter(m => m.id !== id));
  };

  const addToast = (toast: Omit<Toast, 'id' | 'timestamp'>) => {
    const id = Math.random().toString(36).substring(2, 9);
    const newToast = { ...toast, id, timestamp: Date.now() };
    setToasts(prev => [...prev, newToast]);
    
    // Auto remove after 8 seconds
    setTimeout(() => {
      removeToast(id);
    }, 8000);
  };

  const removeToast = (id: string) => {
    setToasts(prev => prev.filter(t => t.id !== id));
  };

  const setApiKey = (key: string | null) => {
      setApiKeyState(key);
  };

  const setFcmToken = (token: string | null) => {
    setFcmTokenState(token);
  };

  const exportData = async () => {
    return JSON.stringify({
      aiProfile,
      savedPersonas,
      userProfile,
      chatHistory,
      gallery,
      journal,
      knowledgeBase,
      memories,
      apiKey,
      fcmToken,
      autoSaveChatInterval,
      autoJsonBackupInterval,
      autoDriveBackup,
      isGoogleDriveConnected,
      proactiveMessageFrequency: aiProfile.proactiveMessageFrequency,
      notificationsEnabled,
      showTimestamps,
      aiCanGenerateImages: aiProfile.aiCanGenerateImages,
    }, null, 2);
  };

  const importData = (json: string) => {
    try {
      const parsed: AppState = JSON.parse(json);
      setAIProfileState(parsed.aiProfile || aiProfile);
      setSavedPersonas(parsed.savedPersonas || [parsed.aiProfile || aiProfile]);
      setUserProfileState(parsed.userProfile || userProfile);
      setChatHistory(parsed.chatHistory || []);
      setGallery(parsed.gallery || []);
      setJournal(parsed.journal || []);
      setKnowledgeBase(parsed.knowledgeBase || []);
      setMemories(parsed.memories || []);
      setApiKeyState(parsed.apiKey || null);
      setFcmTokenState(parsed.fcmToken || null);
      setAutoSaveChatInterval(parsed.autoSaveChatInterval !== undefined ? parsed.autoSaveChatInterval : 30);
      setAutoJsonBackupInterval(parsed.autoJsonBackupInterval !== undefined ? parsed.autoJsonBackupInterval : 5);
      setAutoDriveBackupState(parsed.autoDriveBackup !== undefined ? parsed.autoDriveBackup : false);
      setIsGoogleDriveConnected(parsed.isGoogleDriveConnected !== undefined ? parsed.isGoogleDriveConnected : false);
      setProactiveMessageFrequency(parsed.proactiveMessageFrequency !== undefined ? parsed.proactiveMessageFrequency : 'off');
      setNotificationsEnabledState(parsed.notificationsEnabled !== undefined ? parsed.notificationsEnabled : (typeof Notification !== 'undefined' && Notification.permission === 'granted'));
      setShowTimestampsState(parsed.showTimestamps !== undefined ? parsed.showTimestamps : true);
      setAIProfileState(prev => ({
        ...parsed.aiProfile || prev,
        ambientMode: parsed.aiProfile?.ambientMode ?? false,
        ambientFrequency: parsed.aiProfile?.ambientFrequency || 'off',
        aiCanGenerateImages: parsed.aiProfile?.aiCanGenerateImages ?? false,
      }));
    } catch (e) {
      console.error("Invalid JSON data", e);
      addToast({ title: "Import Failed", message: "Failed to import data. Invalid JSON.", type: "error" });
    }
  };

  const clearHistory = () => {
    setChatHistory([]);
  };

  const resetApp = async () => {
      try {
          await clearDB();
          localStorage.clear();
          // Reset all state variables to their initial values
          setAIProfileState(initialAIProfileState);
          setSavedPersonas([initialAIProfileState]);
          setUserProfileState(initialUserProfileState);
          setChatHistory([]);
          setGallery([]);
          setJournal([]);
          setKnowledgeBase([]);
          setMemories([]);
          setApiKeyState(null);
          setAutoSaveChatState(true);
          setAutoSaveChatInterval(30);
          setAutoJsonBackupState(false);
          setAutoJsonBackupInterval(5);
          setAIProfileState(prev => ({ ...prev, proactiveMessageFrequency: 'off', timeAwareness: true, ambientMode: false, ambientFrequency: 'off' }));
          setShowTutorial(false);
          setShowTimestampsState(true);
          window.location.reload();
      } catch (e) {
          console.error("Failed to reset app", e);
          throw e;
      }
  };

  return (
    <AppContext.Provider value={{
      aiProfile, setAIProfile, savePersona, deletePersona, loadPersona,
      savedPersonas,
      userProfile, setUserProfile, setUserReferenceImage,
      chatHistory, addChatMessage, updateChatMessage, deleteChatMessage, setChatHistory,
      gallery, addToGallery, deleteImageFromGallery,
      journal, addJournalEntry, updateJournalEntry, deleteJournalEntry,
      knowledgeBase, addToKnowledgeBase,
      memories, addMemory, updateMemory, deleteMemory,
      toasts, addToast, removeToast,
      resetApp, exportData, importData, clearHistory,
      apiKey, setApiKey,
      fcmToken, setFcmToken,
      showTutorial, setShowTutorial,
      autoSaveChat, setAutoSaveChat,
      autoSaveChatInterval, setAutoSaveChatInterval,
      autoJsonBackup, setAutoJsonBackup,
      autoJsonBackupInterval, setAutoJsonBackupInterval,
      notificationsEnabled, setNotificationsEnabled,
      autoDriveBackup, setAutoDriveBackup,
      isGoogleDriveConnected, setIsGoogleDriveConnected,
      showTimestamps, setShowTimestamps: setShowTimestampsState,
      proactiveMessageFrequency: aiProfile.proactiveMessageFrequency, setProactiveMessageFrequency,
      ambientMode: aiProfile.ambientMode, setAmbientMode: (enabled: boolean) => setAIProfileState(prev => ({ ...prev, ambientMode: enabled })),
      ambientFrequency: aiProfile.ambientFrequency, setAmbientFrequency: (frequency: 'very_frequently' | 'frequently' | 'occasionally' | 'rarely' | 'off') => setAIProfileState(prev => ({ ...prev, ambientFrequency: frequency })),
      aiCanGenerateImages: aiProfile.aiCanGenerateImages, setAiCanGenerateImages: (enabled: boolean) => setAIProfileState(prev => ({ ...prev, aiCanGenerateImages: enabled })),
    }}>
      {children}
    </AppContext.Provider>
  );
};

export const useApp = () => {
  const context = useContext(AppContext);
  if (!context) throw new Error('useApp must be used within AppProvider');
  return context;
};
